"""
The Canvas object is the primary interface for creating PDF files. See
doc/reportlab-userguide.pdf for copious examples.
"""

from _typeshed import Incomplete
from collections.abc import Callable
from typing import IO, Literal

from reportlab.lib.colors import Color, _ConvertibleToColor
from reportlab.pdfbase.acroform import AcroForm
from reportlab.pdfbase.pdfdoc import Destination
from reportlab.pdfgen.pathobject import PDFPathObject
from reportlab.pdfgen.textobject import PDFTextObject, _PDFColorSetter

class ShowBoundaryValue:
    color: _ConvertibleToColor | None
    width: float
    dashArray: Incomplete
    def __init__(
        self,
        color: _ConvertibleToColor | None = (0, 0, 0),
        width: float = 0.1,
        dashArray: list[float] | tuple[float, ...] | None = None,
    ) -> None: ...
    def __bool__(self) -> bool: ...

class Canvas(_PDFColorSetter):
    bottomup: bool | Literal[0, 1]
    imageCaching: Incomplete
    state_stack: list[Incomplete]
    def __init__(
        self,
        filename: str | IO[bytes],
        pagesize: tuple[float, float] | None = None,
        bottomup: bool | Literal[0, 1] = 1,
        pageCompression=None,
        invariant=None,
        verbosity: int = 0,
        encrypt=None,
        cropMarks=None,
        pdfVersion=None,
        enforceColorSpace=None,
        initialFontName: float | None = None,
        initialFontSize: float | None = None,
        initialLeading: float | None = None,
        cropBox=None,
        artBox=None,
        trimBox=None,
        bleedBox=None,
        lang=None,
    ) -> None:
        """
        Create a canvas of a given size. etc.

        You may pass a file-like object to filename as an alternative to
        a string.
        For more information about the encrypt parameter refer to the setEncrypt method.

        Most of the attributes are private - we will use set/get methods
        as the preferred interface.  Default page size is A4.
        cropMarks may be True/False or an object with parameters borderWidth, markColor, markWidth
        and markLength

        if enforceColorSpace is in ('cmyk', 'rgb', 'sep','sep_black','sep_cmyk') then one of
        the standard _PDFColorSetter callables will be used to enforce appropriate color settings.
        If it is a callable then that will be used.
        """
        ...
    def setEncrypt(self, encrypt) -> None:
        """
        Set the encryption used for the pdf generated by this canvas.
        If encrypt is a string object, it is used as the user password for the pdf.
        If encrypt is an instance of reportlab.lib.pdfencrypt.StandardEncryption, this object is
        used to encrypt the pdf. This allows more finegrained control over the encryption settings.
        """
        ...
    def init_graphics_state(self) -> None: ...
    def push_state_stack(self) -> None: ...
    def pop_state_stack(self) -> None: ...
    STATE_ATTRIBUTES: list[str]
    STATE_RANGE: list[int]
    def setAuthor(self, author: str | None) -> None: ...
    def setDateFormatter(self, dateFormatter) -> None: ...
    def addOutlineEntry(self, title, key, level: int = 0, closed=None) -> None: ...
    def setOutlineNames0(self, *nametree) -> None: ...
    def setTitle(self, title: str | None) -> None: ...
    def setSubject(self, subject: str | None) -> None: ...
    def setCreator(self, creator: str | None) -> None: ...
    def setProducer(self, producer: str | None) -> None: ...
    def setKeywords(self, keywords: str | None) -> None: ...
    def pageHasData(self) -> bool: ...
    def showOutline(self) -> None: ...
    def showFullScreen0(self) -> None: ...
    def setBlendMode(self, v) -> None: ...
    def showPage(self) -> None: ...
    def setPageCallBack(self, func) -> None: ...
    def bookmarkPage(self, key, fit: str = "Fit", left=None, top=None, bottom=None, right=None, zoom=None) -> Destination: ...
    def bookmarkHorizontalAbsolute(self, key, top, left: int = 0, fit: str = "XYZ", **kw) -> Destination: ...
    def bookmarkHorizontal(self, key, relativeX, relativeY, **kw) -> None: ...
    def doForm(self, name) -> None: ...
    def hasForm(self, name: str) -> bool: ...
    def drawInlineImage(
        self,
        image,
        x: float,
        y: float,
        width: float | None = None,
        height: float | None = None,
        preserveAspectRatio: bool = False,
        anchor: str = "c",
        anchorAtXY: bool = False,
        showBoundary: bool = False,
        extraReturn=None,
    ) -> tuple[Incomplete, Incomplete]: ...
    def drawImage(
        self,
        image,
        x: float,
        y: float,
        width: float | None = None,
        height: float | None = None,
        mask=None,
        preserveAspectRatio: bool = False,
        anchor: str = "c",
        anchorAtXY: bool = False,
        showBoundary: bool = False,
        extraReturn=None,
    ) -> tuple[Incomplete, Incomplete]: ...
    def beginForm(self, name, lowerx: int = 0, lowery: int = 0, upperx=None, uppery=None) -> None: ...
    def endForm(self, **extra_attributes) -> None: ...
    def addPostScriptCommand(self, command, position: int = 1) -> None: ...
    def freeTextAnnotation(
        self, contents, DA, Rect=None, addtopage: bool | Literal[0, 1] = 1, name=None, relative: bool | Literal[0, 1] = 0, **kw
    ) -> None: ...
    def textAnnotation(
        self, contents, Rect=None, addtopage: bool | Literal[0, 1] = 1, name=None, relative: bool | Literal[0, 1] = 0, **kw
    ) -> None: ...
    textAnnotation0 = textAnnotation
    def highlightAnnotation(
        self,
        contents,
        Rect,
        QuadPoints=None,
        Color=[0.83, 0.89, 0.95],
        addtopage: bool | Literal[0, 1] = 1,
        name=None,
        relative: bool | Literal[0, 1] = 0,
        **kw,
    ) -> None: ...
    def inkAnnotation(
        self,
        contents,
        InkList=None,
        Rect=None,
        addtopage: bool | Literal[0, 1] = 1,
        name=None,
        relative: bool | Literal[0, 1] = 0,
        **kw,
    ) -> None: ...
    inkAnnotation0 = inkAnnotation
    def linkAbsolute(
        self,
        contents,
        destinationname,
        Rect=None,
        addtopage: bool | Literal[0, 1] = 1,
        name=None,
        thickness: int = 0,
        color: Color | None = None,
        dashArray=None,
        **kw,
    ) -> None: ...
    def linkRect(
        self,
        contents,
        destinationname,
        Rect=None,
        addtopage: bool | Literal[0, 1] = 1,
        name=None,
        relative: bool | Literal[0, 1] = 1,
        thickness: int = 0,
        color: Color | None = None,
        dashArray=None,
        **kw,
    ) -> None: ...
    def linkURL(
        self,
        url,
        rect,
        relative: bool | Literal[0, 1] = 0,
        thickness: int = 0,
        color: Color | None = None,
        dashArray=None,
        kind: str = "URI",
        **kw,
    ) -> None:
        """
        Create a rectangular URL 'hotspot' in the given rectangle.

        if relative=1, this is in the current coord system, otherwise
        in absolute page space.
        The remaining options affect the border appearance; the border is
        drawn by Acrobat, not us.  Set thickness to zero to hide it.
        Any border drawn this way is NOT part of the page stream and
        will not show when printed to a Postscript printer or distilled;
        it is safest to draw your own.
        """
        ...
    def getPageNumber(self) -> int:
        """get the page number for the current page being generated."""
        ...
    def save(self) -> None:
        """
        Saves and close the PDF document in the file.
        If there is current data a ShowPage is executed automatically.
        After this operation the canvas must not be used further.
        """
        ...
    def getpdfdata(self):
        """
        Returns the PDF data that would normally be written to a file.
        If there is current data a ShowPage is executed automatically.
        After this operation the canvas must not be used further.
        """
        ...
    def setPageSize(self, size: tuple[float, float]) -> None:
        """
        accepts a 2-tuple in points for paper size for this
        and subsequent pages
        """
        ...
    def setCropBox(self, size, name: str = "crop") -> None:
        """accepts a 2-tuple in points for name+'Box' size for this and subsequent pages"""
        ...
    def setTrimBox(self, size) -> None: ...
    def setArtBox(self, size) -> None: ...
    def setBleedBox(self, size) -> None: ...
    # NOTE: Only accepts right angles
    def setPageRotation(self, rot: float) -> None: ...
    def addLiteral(self, s: object, escaped: Literal[0, 1] = 1) -> None: ...
    def resetTransforms(self) -> None: ...
    def transform(self, a: float, b: float, c: float, d: float, e: float, f: float) -> None: ...
    def absolutePosition(self, x: float, y: float) -> tuple[float, float]: ...
    def translate(self, dx: float, dy: float) -> None: ...
    def scale(self, x: float, y: float) -> None: ...
    def rotate(self, theta: float) -> None: ...
    def skew(self, alpha: float, beta: float) -> None: ...
    def saveState(self) -> None:
        """
        Save the current graphics state to be restored later by restoreState.

        For example:
            canvas.setFont("Helvetica", 20)
            canvas.saveState()
            ...
            canvas.setFont("Courier", 9)
            ...
            canvas.restoreState()
            # if the save/restore pairs match then font is Helvetica 20 again.
        """
        ...
    def restoreState(self) -> None:
        """restore the graphics state to the matching saved state (see saveState)."""
        ...
    def line(self, x1: float, y1: float, x2: float, y2: float) -> None:
        """
        draw a line segment from (x1,y1) to (x2,y2) (with color, thickness and
        other attributes determined by the current graphics state).
        """
        ...
    def lines(self, linelist) -> None:
        """
        Like line(), permits many lines to be drawn in one call.
        for example for the figure::

            |
          -- --
            |

          crosshairs = [(20,0,20,10), (20,30,20,40), (0,20,10,20), (30,20,40,20)]
          canvas.lines(crosshairs)
        """
        ...
    def cross(
        self,
        x: float,
        y: float,
        size: float = 5,
        gap: float = 1,
        text=None,
        strokeColor=None,
        strokeWidth: float | None = None,
        fontSize: float = 3,
    ) -> None: ...
    def grid(self, xlist, ylist) -> None:
        """
        Lays out a grid in current line style.  Supply list of
        x an y positions.
        """
        ...
    def bezier(self, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, x4: float, y4: float) -> None:
        """Bezier curve with the four given control points"""
        ...
    def arc(self, x1: float, y1: float, x2: float, y2: float, startAng: float = 0, extent: float = 90) -> None:
        """
        Draw a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
        starting at startAng degrees and covering extent degrees.   Angles
        start with 0 to the right (+x) and increase counter-clockwise.
        These should have x1<x2 and y1<y2.
        """
        ...
    def rect(self, x: float, y: float, width: float, height: float, stroke: float = 1, fill: float = 0) -> None:
        """draws a rectangle with lower left corner at (x,y) and width and height as given."""
        ...
    def ellipse(self, x1: float, y1: float, x2: float, y2: float, stroke: float = 1, fill: float = 0) -> None:
        """
        Draw an ellipse defined by an enclosing rectangle.

        Note that (x1,y1) and (x2,y2) are the corner points of
        the enclosing rectangle.
        """
        ...
    def wedge(
        self, x1: float, y1: float, x2: float, y2: float, startAng: float, extent: float, stroke: float = 1, fill: float = 0
    ) -> None:
        """
        Like arc, but connects to the centre of the ellipse.
        Most useful for pie charts and PacMan!
        """
        ...
    def circle(self, x_cen: float, y_cen: float, r: float, stroke: float = 1, fill: float = 0) -> None:
        """draw a cirle centered at (x_cen,y_cen) with radius r (special case of ellipse)"""
        ...
    def roundRect(
        self, x: float, y: float, width: float, height: float, radius: float, stroke: float = 1, fill: float = 0
    ) -> None:
        """
        Draws a rectangle with rounded corners.  The corners are
        approximately quadrants of a circle, with the given radius.
        """
        ...
    def shade(self, shading) -> None: ...
    def linearGradient(self, x0: float, y0: float, x1: float, y1: float, colors, positions=None, extend: bool = True) -> None: ...
    def radialGradient(self, x: float, y: float, radius: float, colors, positions=None, extend: bool = True) -> None: ...
    def drawString(
        self,
        x: float,
        y: float,
        text: str,
        mode: Literal[0, 1, 2, 3, 4, 5, 6, 7] | None = None,
        charSpace: float = 0,
        direction: Literal["LTR", "RTL"] | None = None,
        wordSpace: float | None = None,
        shaping: bool = False,
    ) -> None:
        """Draws a string in the current text styles."""
        ...
    def drawRightString(
        self,
        x: float,
        y: float,
        text: str,
        mode: Literal[0, 1, 2, 3, 4, 5, 6, 7] | None = None,
        charSpace: float = 0,
        direction: Literal["LTR", "RTL"] | None = None,
        wordSpace: float | None = None,
        shaping: bool = False,
    ) -> None:
        """Draws a string right-aligned with the x coordinate"""
        ...
    def drawCentredString(
        self,
        x: float,
        y: float,
        text: str,
        mode: Literal[0, 1, 2, 3, 4, 5, 6, 7] | None = None,
        charSpace: float = 0,
        direction: Literal["LTR", "RTL"] | None = None,
        wordSpace: float | None = None,
        shaping: bool = False,
    ) -> None:
        """
        Draws a string centred on the x coordinate. 

        We're British, dammit, and proud of our spelling!
        """
        ...
    def drawAlignedString(
        self,
        x: float,
        y: float,
        text: str,
        pivotChar: str = ".",
        mode: Literal[0, 1, 2, 3, 4, 5, 6, 7] | None = None,
        charSpace: float = 0,
        direction: Literal["LTR", "RTL"] | None = None,
        wordSpace: float | None = None,
        shaping: bool = False,
    ) -> None: ...
    def getAvailableFonts(self) -> list[Incomplete]: ...
    def listLoadedFonts0(self) -> list[Incomplete]: ...
    def setFont(self, psfontname: str, size: float, leading: float | None = None) -> None: ...
    def setFontSize(self, size: float | None = None, leading: float | None = None) -> None: ...
    def stringWidth(self, text: str, fontName: str | None = None, fontSize: float | None = None) -> float: ...
    def setLineWidth(self, width: float) -> None: ...
    def setLineCap(self, mode) -> None:
        """0=butt,1=round,2=square"""
        ...
    def setLineJoin(self, mode) -> None:
        """0=mitre, 1=round, 2=bevel"""
        ...
    def setMiterLimit(self, limit) -> None: ...
    def setDash(self, array: list[float] | tuple[float, ...] | float = [], phase: float = 0) -> None: ...
    def beginPath(self) -> PDFPathObject: ...
    def drawPath(self, aPath, stroke: int = 1, fill: int = 0, fillMode=None) -> None: ...
    def clipPath(self, aPath, stroke: int = 1, fill: int = 0, fillMode=None) -> None: ...
    def beginText(self, x: float = 0, y: float = 0, direction: Literal["LTR", "RTL"] | None = None) -> PDFTextObject: ...
    def drawText(self, aTextObject: PDFTextObject) -> None: ...
    def setPageCompression(self, pageCompression: bool | Literal[0, 1] | None = 1) -> None: ...
    def setPageDuration(self, duration=None) -> None: ...
    def setPageTransition(
        self, effectname: str | None = None, duration: float = 1, direction: float = 0, dimension: str = "H", motion: str = "I"
    ) -> None: ...
    def getCurrentPageContent(self) -> str: ...
    def setViewerPreference(self, pref, value) -> None: ...
    def getViewerPreference(self, pref): ...
    def delViewerPreference(self, pref) -> None: ...
    def setCatalogEntry(self, key: str, value) -> None: ...
    def getCatalogEntry(self, key: str): ...
    def delCatalogEntry(self, key: str) -> None: ...
    def addPageLabel(self, pageNum, style=None, start=None, prefix=None) -> None: ...
    @property
    def acroForm(self) -> AcroForm: ...
    def drawBoundary(self, sb, x1: float, y1: float, width: float, height: float) -> None: ...
    # Following callbacks are accepted: canvas, kind and label
    def setNamedCB(self, name: str, cb: Callable[[Canvas, str | None, str], None]) -> None: ...
    def getNamedCB(self, name: str) -> Callable[[Canvas, str | None, str], None] | None: ...

__all__ = ["Canvas", "ShowBoundaryValue"]
